#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# Standart, System and Third Party
from threading import Thread
import math

# ROS
import rospy

# Robonomics communication
from robonomics_msgs.msg import Offer, Demand, Result
from ethereum_common.msg import Address, UInt256
from ethereum_common.srv import Accounts, BlockNumber
from ipfs_common.msg import Multihash

from complier_service.ipfs_utils import ipfs_download
from complier_service.footprint import get_token_price


class TraderNode:

    DAI_PRICE = 1   # $1
    DAI_DECIMALS = 10**2 # digits after decimal point
    PRICE_FOR_TON = 287 * (10**3) # KZT

    def __init__(self):
        rospy.init_node('trader')
        rospy.loginfo('Launching trader node...')

        rospy.wait_for_service('/eth/current_block')
        rospy.wait_for_service('/eth/accounts')
        self.accounts = rospy.ServiceProxy('/eth/accounts', Accounts)()
        rospy.loginfo(str(self.accounts)) # AIRA ethereum addresses

        rospy.Subscriber('/liability/infochan/incoming/demand', Demand, self.on_incoming_demand)

        self.signing_offer = rospy.Publisher('/liability/infochan/eth/signing/offer', Offer, queue_size=128)
        self.signing_result = rospy.Publisher('/liability/infochan/eth/signing/result', Result, queue_size=128)

        rospy.loginfo('Trader node is ready!')

    def on_incoming_demand(self, demand: Demand):
        rospy.loginfo('Incoming demand...\n{}'.format(demand))
        if (demand.model.multihash == rospy.get_param('~model') and demand.token.address == rospy.get_param('~payment_token')):
            rospy.loginfo('For my model and token!')
            if demand.cost.uint256 == '0':      # Calculate the price and publish offer
                price = self.calculate_price(demand.objective)
                if price == 0:  # if price is still 0, then there was an error
                    self.send_result(demand)
                else:
                    self.make_offer(demand.objective, UInt256(str(price)))
        else:
            rospy.loginfo('It does not fit my model or token, skip it.')

    def calculate_price(self, objective: Multihash) -> int:
        rospy.loginfo("The demand is with 0 price; Calculating...")
        items = ipfs_download(objective)

        '''
        objective:
        * /co2_volume
        '''

        kilogram_of_co2 = int(items['/co2_volume'].data)
        rospy.loginfo("Kilograms of CO2 {}".format(kilogram_of_co2))
        if kilogram_of_co2 != 0:
            token_price = get_token_price()
            ton_of_co2 = kilogram_of_co2 / 1000
            price = math.ceil(ton_of_co2 * self.PRICE_FOR_TON)
            # price = math.ceil(ton_of_co2 * token_price / self.DAI_PRICE * self.DAI_DECIMALS)
        else:
            price = int(0)
        return price

    def send_result(self, demand: Demand):
        res = Result()
        res.liability = demand.sender
        res.result = demand.objective
        res.success = False

        rospy.loginfo(res)
        self.signing_result.publish(res)

    def get_deadline(self) -> UInt256:
        lifetime = int(rospy.get_param('~order_lifetime'))
        deadline = rospy.ServiceProxy('/eth/current_block', BlockNumber)().number + lifetime
        return UInt256(str(deadline))

    def make_offer(self, objective: Multihash, cost: UInt256):
        rospy.loginfo('Making offer...')

        offer = Offer()
        offer.model = Multihash()
        offer.model.multihash = rospy.get_param('~model')
        offer.objective = objective
        offer.token = Address()
        offer.token.address = rospy.get_param('~payment_token')
        offer.cost = cost
        offer.lighthouse = Address()
        offer.lighthouse.address = rospy.get_param('~lighthouse')
        offer.validator = Address()
        offer.validator.address = '0x0000000000000000000000000000000000000000'
        offer.lighthouseFee = UInt256()
        offer.lighthouseFee.uint256 = '0'
        offer.deadline = self.get_deadline()

        self.signing_offer.publish(offer)
        rospy.loginfo(offer)

    def spin(self):
        rospy.spin()

if __name__ == '__main__':
    TraderNode().spin()
